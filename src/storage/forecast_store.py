"""SQLite storage layer for forecast results.

Core Principles Applied:
- NO FALLBACK: Fail fast on missing data or invalid states
- AGENTIC: Store forecasts generated by Prophet models
- Performance: Cache forecasts with TTL for rapid retrieval
"""
import sqlite3
import json
import uuid
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta


class ForecastStore:
    """SQLite-based storage for forecast results.

    Stores Prophet-generated forecasts with metadata, confidence intervals,
    and performance tracking.
    """

    def __init__(self, db_path: str):
        """Initialize forecast store with database path.

        Args:
            db_path: SQLite database file path

        Raises:
            Exception: If database initialization fails (NO FALLBACK)
        """
        if not db_path:
            raise ValueError("Database path cannot be empty")

        self.db_path = db_path
        self._init_database()

    def _init_database(self):
        """Initialize database schema for forecasts.

        Raises:
            Exception: If schema creation fails (NO FALLBACK)
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            # Enable foreign key enforcement
            cursor.execute('PRAGMA foreign_keys = ON')

            # Forecasts table - stores forecast results
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS forecasts (
                    id TEXT PRIMARY KEY,
                    forecast_type TEXT NOT NULL,
                    forecast_data TEXT NOT NULL,  -- JSON with predictions

                    -- Metadata
                    generated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    forecast_horizon_days INTEGER NOT NULL,
                    data_start_date TEXT NOT NULL,
                    data_end_date TEXT NOT NULL,
                    prediction_start_date TEXT NOT NULL,
                    prediction_end_date TEXT NOT NULL,

                    -- Model performance
                    data_points_used INTEGER NOT NULL,
                    confidence_level REAL DEFAULT 0.95,
                    model_params TEXT,  -- JSON

                    -- Cache management
                    expires_at TIMESTAMP,
                    access_count INTEGER DEFAULT 0,
                    last_accessed TIMESTAMP,

                    -- Accuracy tracking (populated after reality known)
                    actual_vs_predicted TEXT,  -- JSON
                    mae REAL,  -- Mean Absolute Error
                    mape REAL  -- Mean Absolute Percentage Error
                )
            ''')

            # Indexes for performance
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_forecasts_type
                ON forecasts (forecast_type)
            ''')
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_forecasts_expires
                ON forecasts (expires_at)
            ''')
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_forecasts_generated
                ON forecasts (generated_at DESC)
            ''')

            conn.commit()

        except Exception as e:
            conn.rollback()
            raise Exception(f"Forecast database initialization failed: {str(e)}")
        finally:
            conn.close()

    def store(self, forecast_type: str, forecast_data: Dict[str, Any],
              horizon_days: int, data_start: str, data_end: str,
              prediction_start: str, prediction_end: str,
              data_points: int, model_params: Dict[str, Any] = None,
              ttl_hours: int = 24) -> str:
        """Store forecast results.

        Args:
            forecast_type: Type of forecast (call_volume, sentiment, etc.)
            forecast_data: Prophet prediction results
            horizon_days: Forecast horizon in days
            data_start: Start date of training data
            data_end: End date of training data
            prediction_start: Start date of predictions
            prediction_end: End date of predictions
            data_points: Number of data points used
            model_params: Prophet model parameters
            ttl_hours: Time to live in hours

        Returns:
            Forecast ID

        Raises:
            ValueError: Invalid parameters (NO FALLBACK)
            Exception: Database operation failure (NO FALLBACK)
        """
        if not all([forecast_type, forecast_data, data_start, data_end,
                   prediction_start, prediction_end]):
            raise ValueError("All forecast parameters are required")

        if horizon_days <= 0 or data_points <= 0:
            raise ValueError("horizon_days and data_points must be positive")

        forecast_id = str(uuid.uuid4())
        now = datetime.now()
        expires_at = now + timedelta(hours=ttl_hours)

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            cursor.execute('''
                INSERT INTO forecasts (
                    id, forecast_type, forecast_data, forecast_horizon_days,
                    data_start_date, data_end_date, prediction_start_date, prediction_end_date,
                    data_points_used, model_params, expires_at, last_accessed
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                forecast_id,
                forecast_type,
                json.dumps(forecast_data),
                horizon_days,
                data_start,
                data_end,
                prediction_start,
                prediction_end,
                data_points,
                json.dumps(model_params) if model_params else None,
                expires_at,
                now
            ))

            conn.commit()
            return forecast_id

        except Exception as e:
            conn.rollback()
            raise Exception(f"Forecast storage failed: {str(e)}")
        finally:
            conn.close()

    def get_by_id(self, forecast_id: str) -> Optional[Dict[str, Any]]:
        """Get forecast by ID.

        Args:
            forecast_id: Forecast ID

        Returns:
            Forecast data or None if not found/expired

        Raises:
            ValueError: Invalid forecast_id (NO FALLBACK)
        """
        if not forecast_id:
            raise ValueError("forecast_id is required")

        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        try:
            # Get forecast and check expiration
            cursor.execute('''
                SELECT * FROM forecasts
                WHERE id = ? AND (expires_at IS NULL OR expires_at > ?)
            ''', (forecast_id, datetime.now()))

            row = cursor.fetchone()
            if not row:
                return None

            # Update access tracking
            cursor.execute('''
                UPDATE forecasts
                SET access_count = access_count + 1, last_accessed = ?
                WHERE id = ?
            ''', (datetime.now(), forecast_id))

            conn.commit()

            # Convert to dict
            forecast = dict(row)
            forecast['forecast_data'] = json.loads(forecast['forecast_data'])
            if forecast['model_params']:
                forecast['model_params'] = json.loads(forecast['model_params'])
            if forecast['actual_vs_predicted']:
                forecast['actual_vs_predicted'] = json.loads(forecast['actual_vs_predicted'])

            return forecast

        except Exception as e:
            raise Exception(f"Forecast retrieval failed: {str(e)}")
        finally:
            conn.close()

    def get_latest_by_type(self, forecast_type: str) -> Optional[Dict[str, Any]]:
        """Get latest non-expired forecast for type.

        Args:
            forecast_type: Forecast type

        Returns:
            Latest forecast or None
        """
        if not forecast_type:
            raise ValueError("forecast_type is required")

        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        try:
            cursor.execute('''
                SELECT * FROM forecasts
                WHERE forecast_type = ?
                  AND (expires_at IS NULL OR expires_at > ?)
                ORDER BY generated_at DESC
                LIMIT 1
            ''', (forecast_type, datetime.now()))

            row = cursor.fetchone()
            if not row:
                return None

            forecast = dict(row)
            forecast['forecast_data'] = json.loads(forecast['forecast_data'])
            if forecast['model_params']:
                forecast['model_params'] = json.loads(forecast['model_params'])

            return forecast

        except Exception as e:
            raise Exception(f"Forecast retrieval failed: {str(e)}")
        finally:
            conn.close()

    def get_all_by_type(self, forecast_type: str, include_expired: bool = False,
                       limit: int = 10) -> List[Dict[str, Any]]:
        """Get all forecasts of a specific type.

        Args:
            forecast_type: Forecast type
            include_expired: Include expired forecasts
            limit: Maximum results

        Returns:
            List of forecasts
        """
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        try:
            if include_expired:
                cursor.execute('''
                    SELECT * FROM forecasts
                    WHERE forecast_type = ?
                    ORDER BY generated_at DESC
                    LIMIT ?
                ''', (forecast_type, limit))
            else:
                cursor.execute('''
                    SELECT * FROM forecasts
                    WHERE forecast_type = ?
                      AND (expires_at IS NULL OR expires_at > ?)
                    ORDER BY generated_at DESC
                    LIMIT ?
                ''', (forecast_type, datetime.now(), limit))

            rows = cursor.fetchall()
            forecasts = []

            for row in rows:
                forecast = dict(row)
                forecast['forecast_data'] = json.loads(forecast['forecast_data'])
                if forecast['model_params']:
                    forecast['model_params'] = json.loads(forecast['model_params'])
                forecasts.append(forecast)

            return forecasts

        except Exception as e:
            raise Exception(f"Forecast retrieval failed: {str(e)}")
        finally:
            conn.close()

    def update_accuracy(self, forecast_id: str, actual_vs_predicted: Dict[str, Any],
                       mae: float, mape: float):
        """Update forecast with actual results for accuracy tracking.

        Args:
            forecast_id: Forecast ID
            actual_vs_predicted: Actual vs predicted values
            mae: Mean Absolute Error
            mape: Mean Absolute Percentage Error
        """
        if not forecast_id:
            raise ValueError("forecast_id is required")

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            cursor.execute('''
                UPDATE forecasts
                SET actual_vs_predicted = ?, mae = ?, mape = ?
                WHERE id = ?
            ''', (json.dumps(actual_vs_predicted), mae, mape, forecast_id))

            conn.commit()

        except Exception as e:
            conn.rollback()
            raise Exception(f"Forecast accuracy update failed: {str(e)}")
        finally:
            conn.close()

    def cleanup_expired(self) -> int:
        """Remove expired forecasts.

        Returns:
            Number of forecasts deleted
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            cursor.execute('''
                DELETE FROM forecasts
                WHERE expires_at IS NOT NULL AND expires_at <= ?
            ''', (datetime.now(),))

            deleted_count = cursor.rowcount
            conn.commit()

            return deleted_count

        except Exception as e:
            conn.rollback()
            raise Exception(f"Forecast cleanup failed: {str(e)}")
        finally:
            conn.close()

    def get_statistics(self) -> Dict[str, Any]:
        """Get forecast statistics.

        Returns:
            Statistics about stored forecasts
        """
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        try:
            # Total forecasts
            cursor.execute('SELECT COUNT(*) as total FROM forecasts')
            total = cursor.fetchone()['total']

            # By type
            cursor.execute('''
                SELECT forecast_type, COUNT(*) as count
                FROM forecasts
                WHERE expires_at IS NULL OR expires_at > ?
                GROUP BY forecast_type
            ''', (datetime.now(),))
            by_type = {row['forecast_type']: row['count'] for row in cursor.fetchall()}

            # Average accuracy (where available)
            cursor.execute('''
                SELECT AVG(mae) as avg_mae, AVG(mape) as avg_mape
                FROM forecasts
                WHERE mae IS NOT NULL
            ''')
            accuracy = cursor.fetchone()

            # Most accessed
            cursor.execute('''
                SELECT id, forecast_type, access_count
                FROM forecasts
                WHERE expires_at IS NULL OR expires_at > ?
                ORDER BY access_count DESC
                LIMIT 5
            ''', (datetime.now(),))
            most_accessed = [dict(row) for row in cursor.fetchall()]

            return {
                'total_forecasts': total,
                'active_by_type': by_type,
                'average_mae': accuracy['avg_mae'] if accuracy['avg_mae'] else None,
                'average_mape': accuracy['avg_mape'] if accuracy['avg_mape'] else None,
                'most_accessed': most_accessed
            }

        except Exception as e:
            raise Exception(f"Statistics retrieval failed: {str(e)}")
        finally:
            conn.close()

    def delete(self, forecast_id: str) -> bool:
        """Delete a forecast.

        Args:
            forecast_id: Forecast ID

        Returns:
            True if deleted, False if not found
        """
        if not forecast_id:
            raise ValueError("forecast_id is required")

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            cursor.execute('DELETE FROM forecasts WHERE id = ?', (forecast_id,))
            deleted_count = cursor.rowcount
            conn.commit()

            return deleted_count > 0

        except Exception as e:
            conn.rollback()
            raise Exception(f"Forecast deletion failed: {str(e)}")
        finally:
            conn.close()

    def delete_all(self) -> int:
        """Delete all forecasts.

        Returns:
            Number of forecasts deleted
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            cursor.execute('DELETE FROM forecasts')
            deleted_count = cursor.rowcount
            conn.commit()

            return deleted_count

        except Exception as e:
            conn.rollback()
            raise Exception(f"Forecast deletion failed: {str(e)}")
        finally:
            conn.close()

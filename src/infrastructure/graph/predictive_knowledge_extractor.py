"""
Predictive Knowledge Extractor - Transform insights into institutional learning.

Takes insights from pipeline stages and transforms them into patterns, predictions,
and wisdom that can be stored in the knowledge graph for future learning.
"""
from typing import Dict, Any, List, Optional
import logging
from datetime import datetime, timedelta
import uuid

from .knowledge_types import Pattern, Prediction, Wisdom, MetaLearning, PredictiveInsight
try:
    from .predictive_graph_manager import PredictiveGraphManager
    GRAPH_MANAGER_AVAILABLE = True
except ImportError:
    GRAPH_MANAGER_AVAILABLE = False
try:
    from ..events import publish_event, Event, EventType
    EVENTS_AVAILABLE = True
except ImportError:
    EVENTS_AVAILABLE = False

logger = logging.getLogger(__name__)


class PredictiveKnowledgeExtractor:
    """
    Extracts predictive knowledge from pipeline insights.

    Transforms LLM-generated insights into structured knowledge that enables
    the system to learn, predict, and intervene proactively.
    """

    def __init__(self, db_path: Optional[str] = None):
        if db_path is None:
            from ..config.database_config import get_knowledge_graph_database_path
            db_path = get_knowledge_graph_database_path()
        if not GRAPH_MANAGER_AVAILABLE:
            raise RuntimeError("PredictiveGraphManager not available - cannot proceed without proper storage")
        self.graph_manager = PredictiveGraphManager(db_path)

    async def extract_knowledge(self, insight: PredictiveInsight, context: Dict[str, Any]) -> None:
        """
        Extract predictive knowledge from a pipeline insight.

        Args:
            insight: The insight generated by a pipeline stage
            context: Additional context about the source of the insight

        Raises:
            Exception: When knowledge extraction fails (NO FALLBACK)
        """
        if insight.priority == 'skip':
            logger.info(f"ðŸš« Skipping knowledge extraction based on priority")
            return

        logger.info(f"ðŸ§  Extracting {insight.insight_type} knowledge from {insight.source_stage}")
        logger.info(f"   Priority: {insight.priority}, Learning: {insight.learning_value}")
        logger.info(f"   Reasoning: {insight.reasoning}")

        try:
            insight_type = insight.insight_type.lower()
            if insight_type == 'pattern':
                await self._extract_pattern(insight, context)
            elif insight_type == 'prediction':
                await self._extract_prediction(insight, context)
            elif insight_type == 'wisdom':
                await self._extract_wisdom(insight, context)
            elif insight_type == 'meta_learning':
                await self._extract_meta_learning(insight, context)
            else:
                logger.warning(f"Unknown insight type: {insight.insight_type}")

            # Publish knowledge extraction event
            await self._publish_knowledge_event(insight, context)

            logger.info(f"âœ… Successfully extracted {insight.insight_type} knowledge")

        except Exception as e:
            # NO FALLBACK: Fail fast on knowledge extraction errors
            logger.error(f"Failed to extract knowledge from insight: {e}")
            raise RuntimeError(f"Knowledge extraction failed: {str(e)}")

    async def _extract_pattern(self, insight: PredictiveInsight, context: Dict[str, Any]) -> None:
        """Extract a behavioral or operational pattern."""
        content = insight.content

        pattern = Pattern(
            pattern_id=f"PATTERN_{uuid.uuid4().hex[:8]}",
            pattern_type='behavioral',
            title=content.key,
            description=content.value,
            conditions={'insight_impact': content.impact},
            outcomes={'confidence': content.confidence},
            confidence=content.confidence,
            occurrences=1,  # First observation
            success_rate=0.5,  # Initial default
            last_observed=datetime.fromisoformat(insight.timestamp.replace('Z', '+00:00')) if isinstance(insight.timestamp, str) else datetime.fromisoformat(insight.timestamp),
            source_pipeline=insight.source_stage
        )

        # NO FALLBACK: Store pattern or fail
        await self.graph_manager.store_pattern(pattern)
        logger.info(f"ðŸ“Š Stored pattern: {pattern.title}")

    async def _extract_prediction(self, insight: PredictiveInsight, context: Dict[str, Any]) -> None:
        """Extract a predictive insight about future events."""
        content = insight.content

        prediction = Prediction(
            prediction_id=f"PRED_{uuid.uuid4().hex[:8]}",
            prediction_type='risk_assessment',
            target_entity=insight.customer_context.customer_id,
            target_entity_id=insight.customer_context.customer_id,
            predicted_event=content.key,
            probability=content.confidence,
            confidence=content.confidence,
            time_horizon='short_term',
            supporting_patterns=[content.impact],
            evidence_strength=content.confidence,
            created_at=datetime.fromisoformat(insight.timestamp.replace('Z', '+00:00')) if isinstance(insight.timestamp, str) else datetime.fromisoformat(insight.timestamp),
            expires_at=(datetime.fromisoformat(insight.timestamp.replace('Z', '+00:00')) if isinstance(insight.timestamp, str) else datetime.fromisoformat(insight.timestamp)) + timedelta(days=30),  # Default 30-day expiration
            validated=None,  # Not yet validated
            validation_date=None  # Not yet validated
        )

        # NO FALLBACK: Store prediction or fail
        await self.graph_manager.store_prediction(prediction)
        logger.info(f"ðŸ”® Stored prediction: {prediction.predicted_event}")

    async def _extract_wisdom(self, insight: PredictiveInsight, context: Dict[str, Any]) -> None:
        """Extract strategic wisdom and institutional knowledge."""
        content = insight.content

        wisdom = Wisdom(
            wisdom_id=f"WISDOM_{uuid.uuid4().hex[:8]}",
            wisdom_type='strategic_insight',
            domain=insight.customer_context.loan_type,
            insight=content.value,
            applications=[content.impact],
            success_indicators=[content.key],
            derived_from_patterns=[insight.source_stage],
            evidence_base={'confidence': content.confidence, 'impact': content.impact},
            confidence_level=content.confidence,
            discovered_at=datetime.fromisoformat(insight.timestamp.replace('Z', '+00:00')) if isinstance(insight.timestamp, str) else datetime.fromisoformat(insight.timestamp),
            times_applied=0,
            application_success_rate=0.0
        )

        # NO FALLBACK: Store wisdom or fail
        await self.graph_manager.store_wisdom(wisdom)
        logger.info(f"ðŸ§  Stored wisdom: {wisdom.insight[:50]}...")

    async def _extract_meta_learning(self, insight: PredictiveInsight, context: Dict[str, Any]) -> None:
        """Extract meta-learning about the system's learning process."""
        content = insight.content

        meta_learning = MetaLearning(
            meta_id=f"META_{uuid.uuid4().hex[:8]}",
            meta_type='system_improvement',
            learning_insight=content.value,
            improvement_opportunity=content.impact,
            optimization_suggestion=content.key,
            accuracy_metrics={'confidence': content.confidence},
            learning_velocity=content.confidence,
            knowledge_gaps=[insight.reasoning],
            observed_at=datetime.fromisoformat(insight.timestamp.replace('Z', '+00:00')) if isinstance(insight.timestamp, str) else datetime.fromisoformat(insight.timestamp),
            system_version="v2.0"
        )

        # NO FALLBACK: Store meta-learning or fail
        await self.graph_manager.store_meta_learning(meta_learning)
        logger.info(f"ðŸ”„ Stored meta-learning: {meta_learning.learning_insight[:50]}...")

    async def _publish_knowledge_event(self, insight: PredictiveInsight, context: Dict[str, Any]) -> None:
        """Publish an event about knowledge extraction."""
        event_data = {
            'event_type': f'KNOWLEDGE_EXTRACTED_{insight.insight_type.upper()}',
            'timestamp': datetime.utcnow().isoformat(),
            'source': 'predictive_knowledge_extractor',
            'insight_type': insight.insight_type,
            'source_stage': insight.source_stage,
            'priority': insight.priority,
            'learning_value': insight.learning_value,
            'context': context,
            'reasoning': insight.reasoning
        }

        if not EVENTS_AVAILABLE:
            raise RuntimeError("Event system not available - cannot proceed without event publishing")

        # NO FALLBACK: Publish event or fail
        event = Event(
            event_type=EventType.KNOWLEDGE_EXTRACTED,
            event_id=f"knowledge_{uuid.uuid4().hex[:8]}",
            timestamp=datetime.utcnow(),
            source_service="predictive_knowledge_extractor",
            payload=event_data
        )
        publish_event(event)

    async def get_relevant_patterns(self, context: Dict[str, Any]) -> List[Pattern]:
        """Get patterns relevant to the current context."""
        # NO FALLBACK: Query patterns or fail
        return await self.graph_manager.get_patterns_by_context(context)

    async def get_predictions_for_entity(self, entity_type: str, entity_id: str) -> List[Prediction]:
        """Get active predictions for a specific entity."""
        # NO FALLBACK: Query predictions or fail
        return await self.graph_manager.get_predictions_for_entity(entity_type, entity_id)

    async def validate_prediction(self, prediction_id: str, outcome: bool) -> None:
        """Validate a prediction with actual outcome."""
        await self.graph_manager.validate_prediction(prediction_id, outcome)
        logger.info(f"âœ… Validated prediction {prediction_id}: {'SUCCESS' if outcome else 'FAILED'}")

    async def update_pattern_evidence(self, pattern_id: str, new_observation: Dict[str, Any]) -> None:
        """Update a pattern with new evidence."""
        await self.graph_manager.update_pattern_evidence(pattern_id, new_observation)
        logger.info(f"ðŸ“Š Updated pattern {pattern_id} with new evidence")


# Global instance
_knowledge_extractor = None

def get_predictive_knowledge_extractor() -> PredictiveKnowledgeExtractor:
    """Get the global predictive knowledge extractor instance."""
    global _knowledge_extractor
    if _knowledge_extractor is None:
        # NO FALLBACK: Fail fast if dependencies not available
        try:
            _knowledge_extractor = PredictiveKnowledgeExtractor()
        except RuntimeError as e:
            logger.error(f"Failed to initialize PredictiveKnowledgeExtractor: {e}")
            raise RuntimeError(f"Cannot proceed without predictive knowledge system: {e}")
    return _knowledge_extractor